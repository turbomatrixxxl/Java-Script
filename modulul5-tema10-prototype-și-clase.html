<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Modulul 5 Tema 10 Prototype și clase</title>
  </head>
  <body>
    <h1>Modulul 5 - Tema 10 - Prototype și clase</h1>
    <a href="" , target="_blank"><b>Lectie video</b></a>

    <h2>Programarea orientată pe obiecte</h2>
    <p>
      <b>Programarea procedurală</b> - un set de funcții și variabile care nu au
      vreo legătură explicită între ele și sunt folosite la stocarea și
      procesarea informațiilor. Această abordare este una simplă și este
      potrivită pentru sarcini în care nu există entități strâns legate (date și
      funcții pentru procesare).
    </p>
    <p>
      Să preluăm un exemplu de cod procedural în care există variabile și o
      funcție pentru calcularea rezultatului.
    </p>
    <p>
      <b>Programarea orientată pe obiecte (POO)</b> - o metodologie bazată pe
      reprezentarea unui program ca pe un set de obiecte, fiecare obiect
      conţinând date (proprietăţi) şi metode de interacţionare cu acestea.
    </p>
    <p>
      Să utilizăm <b>POO</b>-ul într-un exemplu unde datele sunt colectate
      într-un <b>obiect</b> employee.
    </p>
    <p>
      Cu această abordare, metoda nu are parametri, sunt utilizate proprietățile
      obiectului care sunt setate la crearea sa și, eventual, modificate prin
      propriile sale metode. La ieșire, obținem o entitate cu o interfață
      simplă, ceea ce reduce complexitatea codului.
    </p>
    <p></p>
    <p>
      <b>POO</b> este o abordare a programării pentru modelarea/organizarea
      codului, rezolvând o problemă mare, și anume - structurarea informațiilor
      din punct de vedere al gestionării, ceea ce îmbunătățește semnificativ
      controlul procesului.
    </p>

    <h3>Entity</h3>
    <p>
      Imaginează-ți că proiectăm o mașină. Va avea motor, patru roți, rezervor
      de combustibil etc. Mașina trebuie să poată porni, accelera și încetini.
      Știm deja cum interacționează motorul și roțile, adică în funcție de ce
      legi, diferite părți ale mașinii interacționează între ele.
    </p>

    <h4>Class</h4>
    <p>
      Descriem toate piesele care alcătuiesc mașina, modul în care aceste părți
      interacționează între ele și ce trebuie să facă șoferul pentru ca mașina
      să încetinească, să se aprindă farurile și multe altele. Rezultatul muncii
      noastre va fi o schiță (șablon/schemă). Tocmai am dezvoltat ceea ce în
      <b>OOP</b> se numește o <b>clasă</b>.
    </p>
    <p>
      <b>Class</b> - un mod de a descrie o entitate care definește starea sa și
      comportamentul care depinde de acea stare, precum și regulile de
      interacțiune cu această entitate (contract).
    </p>
    <p>
      În cazul nostru, clasa descrie o entitate - mașina. Proprietățile clasei
      sunt motorul, roțile, farurile etc. Metodele clasei ar fi deschiderea
      ușii, pornirea motorului, accelerarea etc.
    </p>

    <h4>Instanță</h4>
    <p>
      Am proiectat mașina și urmează să iasă de pe linia de asamblare. Fiecare
      dintre ele funcționează la fel, toate sistemele interacționează exact așa
      cum le-am proiectat, dar fiecare mașină este totuși unică. Toate au un
      număr de caroserie și motor, dar toate numerele sunt diferite, mașinile
      diferă prin culoare, decorațiuni interioare. Aceste mașini sunt instanțe a
      clasei noastre.
    </p>
    <p>
      <b>Instanță (obiect)</b> - este o instanță separată a unei clase care are
      o stare și un comportament specific care este complet definit de clasă.
      Este ceea ce a fost creat după template, adică după descrierea din clasă.
    </p>
    <p>
      Simplu vorbind, un obiect are valori specifice pentru proprietățile și
      metodele sale și operează asupra acelor proprietăți, pe baza regulilor
      definite în clasă. În acest exemplu, dacă clasa este doar o mașină
      abstractă din desen, atunci obiectul este deja o mașină reală care stă în
      parcarea blocului.
    </p>

    <h4>Interface</h4>
    <p>
      Când ne apropiem de un aparat de cafea sau ne urcăm la volanul unei
      mașini, există un set de comenzi cu care putem interacționa.
    </p>
    <p>
      <b>Interfața</b> - este un set de proprietăți și metode dintr-o clasă ce
      sunt disponibile pentru utilizare atunci când lucrăm cu o instanță.
    </p>
    <p>
      O interfață descrie o clasă, definind clar toate acțiunile posibile asupra
      ei. Un bun exemplu de interfață este tabloul de bord al unei mașini, care
      permite să apelăm metode precum accelerare, frânare, schimbarea vitezelor,
      aprinderea farurilor etc.
    </p>
    <p>
      Când descriem o interfață de clasă, este foarte important să găsim un
      echilibru între flexibilitate și simplitate. O clasă cu o interfață simplă
      va fi ușor de utilizat, dar vor exista probleme pe care nu le va putea
      rezolva.
    </p>
    <p>
      Dacă interfața este flexibilă, atunci, cel mai probabil se va folosi în
      metode destul de complexe, cu un număr mare de parametri, care vă vor
      permite să faceți foarte multe. Totuși, utilizarea ei va fi plină de
      dificultăți și există riscul de a face o greșeală, confundând ceva.
    </p>

    <h2>Prototypal Inheritance</h2>
    <p>
      OOP în JavaScript este construit pe baza moștenirii de prototip. Obiectele
      pot fi înlănțuite, astfel încât, o proprietate care nu se găsește într-un
      obiect să fie căutată automat în alt obiect. Nodul ce leagă două sau mai
      multe obiecte este, de fapt, o proprietate ascunsă, numită
      <b>[[Prototype]]</b> și este afișată ca<b> __proto__</b> în consola
      browserului.
    </p>

    <h3>Prototipul obiectului</h3>
    <p>
      Metoda <b>Object.create(obj)</b> creează și returnează un nou obiect ce-l
      leagă de obj.
    </p>
    <p>
      Obiectul la care se face referire în proprietatea <b>__proto__</b>,
      dintr-un obiect se numește <b>prototip</b>. În exemplul nostru, obiectul
      <b>animal</b> este <b>prototipul</b> obiectului <b>dog</b>. Metoda
      <b>isPrototypeOf()</b> verifică dacă obiectul <b>animal</b> este
      <b>prototip</b> pentru <b>dog</b> și returnează <b>true</b> sau <b></b>.
    </p>
    <p>
      Apelul <b>dog.name</b> funcționează în mod evident - returnează
      proprietatea <b>name</b> din obiectul <b></b>. La accesarea
      <b>dog.legs</b>, interpretorul caută proprietatea <b>legs</b> în obiectul
      <b>dog</b>, nu o găsește și continuă căutarea în referința
      <b>dog.__proto__</b>, adică, în acest caz, în obiectul <b>animal</b> care
      este prototipul său.
    </p>
    <p>
      Un prototip funcționează ca
      <b
        >un spațiu de stocare de rezervă a proprietăților și metodelor unui
        obiect</b
      >. Este utilizată automat la căutarea acestora. Un obiect care acționează
      ca un prototip poate avea propriul său prototip. Acela, la rândul său,
      poate avea propriul prototip și așa mai departe.
    </p>
    <p>
      Interpretorul caută în obiect o proprietate după nume, dacă nu o găsește,
      atunci caută proprietatea <b>__proto__</b>, adică se îndreaptă către
      o<b>biectul-prototip</b>, și apoi - spre <b>prototipul prototipului</b>.
      Dacă interpretorul ajunge la sfârșitul lanțului și nu găsește o
      proprietate cu acel nume, atunci va returna <b>undefined</b>.
    </p>
    <p><b>BINE DE ȘTIUT</b></p>
    <p>
      În specificație, proprietatea <b>__proto__</b> este desemnată ca
      <b>[[Prototype]]</b>. Parantezele pătrate duble sunt importante aici, ele
      indică faptul că aceasta este o proprietate internă cu informații
      utilitare.
    </p>

    <h3>Metoda hasOwnProperty()</h3>
    <p>
      Acum că am văzut cum funcționează căutările de proprietăți ale obiectelor,
      ar trebui să fie clar de ce bucla <b>for...in</b> nu distinge
      proprietățile unui obiect de prototipul său.
    </p>
    <p>
      Acesta este și motivul pentru care folosim metoda
      obj.hasOwnProperty(prop). Returnează true dacă proprietatea prop aparține
      obiectului obj, nu prototipului său, iar în caz contrar, false.
    </p>
    <p>
      Metoda O<b>bject.keys(obj)</b> va returna o matrice doar cu cheile proprii
      ale obiectului obj, de aceea, în practică, se folosește aceasta și nu
      <b>for...in</b>.
    </p>

    <h2>Class</h2>
    <p>
      Sintaxa obiectului permite să creăm un singur obiect. Dar, adesea trebuie
      să creăm mai multe obiecte de același tip, cu același set de proprietăți,
      dar cu valori și metode diferite de interacționare. Toate acestea trebuie
      făcute dinamic, în timpul execuției programului. Pentru a face acest
      lucru, vom utiliza clase - o sintaxă specială pentru a declara funcții ce
      crează obiecte.
    </p>

    <h3>Declararea unei clase</h3>
    <p>
      O declarare de clasă începe cu keyword-ul <b>class</b>, urmat de numele
      clasei și acolade pentru corpul acesteia. Clasele sunt de obicei numite cu
      majuscule, iar numele, în sine, reflectă tipul de obiect creat (un
      substantiv).
    </p>
    <p>
      Rezultatul apelării <b>new User()</b> este un obiect numit
      <b>instanță</b> de clasă, deoarece conține datele și comportamentul
      descris de clasă.
    </p>
    <p><b>BINE DE ȘTIUT </b></p>
    <p>
      Construirea unei clase depinde în totalitate de ceea ce aveți nevoie. În
      cazul nostru, clasa reprezintă un utilizator, așa că vom adăuga câmpuri
      pentru nume și e-mail.
    </p>

    <h3>Constructorul clasei</h3>
    <p>
      Pentru a inițializa o instanță, în clase există o metodă constructor. Dacă
      nu este declarat, este creat un constructor implicit - o funcție goală
      care nu modifică instanța.
    </p>
    <p>
      Apelarea unei clase cu operatorul <b>new</b> are ca rezultat crearea unui
      nou obiect și invocarea constructorului în contextul acelui obiect. Adică,
      <b>this</b> din interiorul constructorului se va referi la obiectul nou
      creat. Acest lucru permite să adăugăm fiecărui obiect, proprietăți ce au
      același nume, dar valori diferite.
    </p>
    <p>
      Proprietățile name și email se numesc proprietăți publice, deoarece vor fi
      proprietăți specifice obiectului instanței și pot fi accesate printr-un
      punct.
    </p>

    <h3>Parameter Object</h3>
    <p>
      Clasele pot accepta un număr mare de date de intrare pentru proprietățile
      viitorului obiect. Prin urmare, paternul <b>Parameter Object</b> poate fi
      aplicat, pasând un singur obiect cu proprietăți denumite logic, în loc de
      un set de argumente fără legătură.
    </p>

    <h3>Metodele clasei</h3>
    <p>
      Pentru a lucra cu proprietățile viitoarei instanțe, se folosesc metodele
      clasei - funcții care vor fi disponibile instanței în prototipul acesteia.
    </p>

    <h3>Proprietăți private</h3>
    <p>
      <b>Încapsularea</b> - este un concept pentru a ascunde detaliile interne
      ale unei clase. Programatorul care va utiliza clasa ar trebui să aibă
      acces doar la interfața publică - un set de proprietăți publice și metode
      ale clasei.
    </p>
    <p>
      În clase, încapsularea este realizată cu ajutorul proprietăților private
      care pot fi accesate numai în cadrul acestora.
    </p>
    <p>
      Să presupunem că email-ul utilizatorului nu ar trebui să fie disponibil
      pentru modificare directă din exterior. Adăugând simbolul <b>#</b> la
      numele proprietății, îl facem privat. Este obligatorie declararea unei
      proprietăți private înainte de inițializarea sa în constructor.
    </p>

    <h3>Getters și Setters</h3>
    <p>
      Getters și setters sunt o sintaxă mai concisă de declarare a metodei
      pentru interacțiunea cu proprietăți. Getter-ul și setter-ul imită o
      proprietate publică normală, dar permite să modificăm alte proprietăți
      printr-o modalitate mai ușoară. Un getter este executat atunci când se
      încearcă obținerea valorii unei proprietăți, iar un setter este executat
      când se modifică valoarea.
    </p>
    <p>
      Getters și setterele sunt bune de utilizat pentru operațiile simple de
      citire și modificare, în special a celor private, fiind ca o interfață
      publică pentru acestea. Pentru a lucra cu o proprietate care stochează o
      matrice sau un obiect, acestea nu vor funcționa.
    </p>
    <p>
      Am declarat <b>getter</b> și <b>setter</b> pentru proprietatea
      <b>email</b>, prefixând numele proprietății cu cuvintele cheie,
      <b>get</b> și <b>set</b>. În cadrul acestor metode, fie returnăm valoarea
      proprietății private #email, fie îi modificăm valoarea. <b>Getterul</b> și
      <b>setterul</b> merg mână în mână și trebuie să fie denumite la fel.
    </p>
    <p>
      Când accesăm <b>vasile.email</b>, <b>getter-ul get email() {...}</b> este
      apelat și codul său este executat. Când încercăm asignare de valoare
      <b>vasile.email = "vasile@supermail.com"</b>, se apelează
      <b>setter-ul set email(newEmail) {...}</b>, unde șirul
      <b>"vasile@supermail.com"</b> va fi valoarea parametrului <b>newEmail</b>.
    </p>
    <p>
      Avantajul este că acestea sunt metode, ceea ce înseamnă că putem executa
      cod suplimentar, de exemplu, cu diferite verificări, spre deosebire de
      efectuarea aceleiași operații directe pe o proprietate.
    </p>

    <h3>Proprietăți statice</h3>
    <p>
      Față de proprietățile publice și private ale unei instanțe viitoare, o
      clasă își poate declara propriile proprietăți care sunt disponibile numai
      pentru clasa respectivă, dar nu și pentru instanțe - proprietăți statice
      (<b>static</b>). Sunt utile pentru stocarea informațiilor specifice doar
      clasei în sine.
    </p>
    <p>
      Să adăugăm o proprietate privată <b>role</b> la clasa <b>User</b> - care
      va defini un set de permisiuni, de exemplu: administrator, editor,
      utilizator etc. Vom stoca posibilele roluri ca o proprietate statică
      <b>Roles</b>, sub forma unui obiect cu proprietăți.
    </p>
    <p>
      Proprietățile statice sunt declarate în corpul clasei. Cuvântul cheie
      <b>static</b> este adăugat înaintea numelui proprietății.
    </p>
    <p>
      Proprietățile statice pot fi, de asemenea, private, ceea ce înseamnă că
      pot fi accesate numai în cadrul clasei. Pentru a face acest lucru, numele
      proprietății trebuie să înceapă cu simbolul <b>#</b>, la fel ca și
      proprietățile private. Accesarea unei proprietăți statice private în afara
      corpului clasei va genera o eroare.
    </p>

    <h3>Metode statice</h3>
    <p>
      Într-o clasă, putem declara nu numai metodele viitoarei instanțe, ci și
      metode disponibile numai clasei - metode statice care pot fi fie publice,
      fie private. Sintaxa declarației este similară cu proprietățile statice,
      cu excepția faptului că valoarea va fi o metodă.
    </p>
    <p>
      O particularitate a metodelor statice este că atunci când sunt apelate,
      cuvântul cheie <b>this</b>, se referă la clasa în sine. Asta înseamnă că o
      metodă statică poate accesa proprietățile statice ale clasei, dar nu și
      proprietățile instanței. Este logic, deoarece metodele statice sunt
      apelate de clasă, și nu de instanțe.
    </p>

    <h3>Moștenirea claselor</h3>
    <p>
      Cuvântul cheie extends permite să implementăm moștenirea clasei, atunci
      când o clasă (copil, derivat) moștenește proprietățile și metodele alteia
      (părinte).
    </p>
    <p><b>class Child extends Parent { // ... }</b></p>
    <p>
      În expresia class <b>Child</b> extends <b>Parent</b>, clasa copil
      <b>Child</b> moștenește (se extinde) din clasa părinte <b>Parent</b>.
    </p>
    <p>
      De aici, înțelegem că putem declara o clasă de bază care deține
      caracteristici și metode comune pentru un grup de clase derivate care
      moștenesc proprietățile și metodele părintelui.
    </p>
    <p>
      De exemplu, o aplicație are utilizatori cu roluri diferite -
      administrator, redactor de articole, manager de conținut etc. Fiecare tip
      de utilizator are un set de caracteristici comune, cum ar fi email-ul și
      parola, dar și caracteristici unice.
    </p>
    <p>
      După ce am făcut clase independente pentru fiecare tip de utilizator, vom
      obține o duplicare a proprietăților și metodelor comune și, dacă este
      necesar, spre exemplu, să modificăm numele unei proprietăți. Va trebui să
      trecem prin toate clasele pentru a face această modificare.
    </p>
    <p>
      Mai ușor ar fi să creăm o clasă generică <b>User</b>, care va stoca un set
      de proprietăți și metode comune, apoi, clasele pentru fiecare tip de
      utilizator vor moșteni acest set din clasa <b>User</b>. Dacă trebuie
      modificat ceva comun, va fi suficient să schimbăm doar codul clasei
      <b>User</b>.
    </p>
    <p>
      Clasa ContentEditor moștenește constructorul din clasa <b>User</b>,
      getterul și setterul email, precum și proprietatea publică cu același
      nume. Este important să ne amintim că proprietățile și metodele private
      ale clasei părinte nu sunt moștenite de clasa copil.
    </p>

    <h3>Constructorul clasei copil</h3>
    <p>
      Primul pas în constructorul clasei copil este să apelăm funcția specială,
      <b>super(arguments)</b> - acesta este un alias pentru constructorul clasei
      părinte. În caz contrar, dacă încercăm să accesăm this în constructorul
      unei clase copil, vom primi o eroare. Când apelăm constructorul clasei
      părinte, transmitem argumentele necesare pentru a inițializa
      proprietățile.
    </p>

    <h3>Metodele clasei copil</h3>
    <p>
      Într-o clasă copil, putem declara metode care vor fi disponibile doar
      instanțelor.
    </p>

    <script src="./js/index10.js"></script>
  </body>
</html>
